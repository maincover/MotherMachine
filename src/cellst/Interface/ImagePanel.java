/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package cellst.Interface;

import ij.*;
import ij.gui.*;
import ij.process.*;

import java.awt.*;
import java.util.ArrayList;

import cellst.Image.ShapeSet;
import cellst.Main.Utils;

/**
 * JPanel displaying an ImageStack.
 *
 * @author Magali Vangkeosay, David Parsons
 */
public class ImagePanel extends javax.swing.JPanel
{
  // ==========================================================================
  // ===                       ENUM
  // ==========================================================================

  // ==========================================================================
  // ===                       CONSTRUCTOR
  // ==========================================================================
  /**
   * Creates new form ImageJPanel and initiate its ImageStack.
   */
  public ImagePanel()
  {
    initComponents();

    image = new ImageStack();
  }

  /**
   * This method is called from within the constructor to initialize the form.
   * WARNING: Do NOT modify this code. The content of this method is always
   * regenerated by the Form Editor.
   */
  @SuppressWarnings("unchecked")
  // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
  private void initComponents()
  {

    addMouseWheelListener(new java.awt.event.MouseWheelListener()
    {
      public void mouseWheelMoved(java.awt.event.MouseWheelEvent evt)
      {
        formMouseWheelMoved(evt);
      }
    });
    addMouseListener(new java.awt.event.MouseAdapter()
    {
      public void mousePressed(java.awt.event.MouseEvent evt)
      {
        formMousePressed(evt);
      }
      public void mouseEntered(java.awt.event.MouseEvent evt)
      {
        formMouseEntered(evt);
      }
    });
    addComponentListener(new java.awt.event.ComponentAdapter()
    {
      public void componentResized(java.awt.event.ComponentEvent evt)
      {
        formComponentResized(evt);
      }
    });
    addMouseMotionListener(new java.awt.event.MouseMotionAdapter()
    {
      public void mouseDragged(java.awt.event.MouseEvent evt)
      {
        formMouseDragged(evt);
      }
    });
    addKeyListener(new java.awt.event.KeyAdapter()
    {
      public void keyPressed(java.awt.event.KeyEvent evt)
      {
        formKeyPressed(evt);
      }
      public void keyReleased(java.awt.event.KeyEvent evt)
      {
        formKeyReleased(evt);
      }
    });

    javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
    this.setLayout(layout);
    layout.setHorizontalGroup(
      layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
      .addGap(0, 201, Short.MAX_VALUE)
    );
    layout.setVerticalGroup(
      layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
      .addGap(0, 200, Short.MAX_VALUE)
    );
  }// </editor-fold>//GEN-END:initComponents

  // ==========================================================================
  // ===                      EVENT METHODS
  // ==========================================================================
  /**
   * Manages component resizing event.
   *
   * @param evt
   */
  private void formComponentResized(java.awt.event.ComponentEvent evt)//GEN-FIRST:event_formComponentResized
  {//GEN-HEADEREND:event_formComponentResized
    // =============== Update preferred Sizes =================================
    setPreferredSize(getSize());
    getParent().setPreferredSize(getParent().getSize());

    // ============= If image is not null or empty ============================
    // And if image was smaller or equal to frame dimension. 
    // Change zoom so that image will be set to frame dimension.
    // ( If image was already bigger than frame, zoom is not changed. )
    if (image != null
        && image.getSize() > 0
        && lastZoomWidth <= lastSize.width
        && lastZoomHeight <= lastSize.height)
    {
      // ----- Compute zoom so image fill exactly the frame -------------------
      zoom = getZoomToFill();

      // ---- Register top left corner to (0, 0) ------------------------------
      // Indeed whole image is shown so topleft corner of shown image 
      // corresponds to the real topleft corner of the image.
      topLeftCorner = new Point(0, 0);

      // ---- Update lastZoomWidth and LastZoomHeight -------------------------
      lastZoomWidth = image.getWidth() * zoom;
      lastZoomHeight = image.getHeight() * zoom;
    }

    // =========== Update lastSize ============================================
    lastSize = getSize();

    // ========== repaint =====================================================
    repaint();
  }//GEN-LAST:event_formComponentResized

  private void formMouseWheelMoved(java.awt.event.MouseWheelEvent evt)//GEN-FIRST:event_formMouseWheelMoved
  {//GEN-HEADEREND:event_formMouseWheelMoved
    // ============= get wheel rotation value =================================
    int val = evt.getWheelRotation();

    // ============ If CTRL key is pressed ====================================
    //               Zoom in or out image.
    if (evt.isControlDown())
    {
      zoom(((double) -val) / 10.);
    }
    // ============ If ALT key is pressed ====================================
    //               image moves horizontaly
    else if (evt.isAltDown())
    {
      horizontalMove(-val * 10);
    }
    // ============ If SHIFT key is pressed ====================================
    //               image moves verticaly
    else if (evt.isShiftDown())
    {
      verticalMove(-val * 10);
    }
    // ============ If no key is pressed ====================================
    //              slice is changed in stack.
    else
    {
      slice = slice + val;
      slice = Math.min(slice, image.getSize());
      slice = Math.max(slice, 1);
      
    }

    // ============== Repaint image and pack frame ===========================
    repaint();
  }//GEN-LAST:event_formMouseWheelMoved

  private void formMouseDragged(java.awt.event.MouseEvent evt)//GEN-FIRST:event_formMouseDragged
  {//GEN-HEADEREND:event_formMouseDragged
    // ============= If spacebar is pressed ==================================
    //                 move image
    if (spacebar)
    {
      // ----- Get mouse position -----------
      Point pos = evt.getPoint();

      // ----- Moves image using last recorded mouse position ---------
      horizontalMove(mousePos.x - pos.x);
      verticalMove(mousePos.y - pos.y);

      // ------ repaint image and pack frame -----------
      repaint();

      // -------- update last recorded mouse position ----
      mousePos = pos;
    }
  }//GEN-LAST:event_formMouseDragged

  private void formKeyPressed(java.awt.event.KeyEvent evt)//GEN-FIRST:event_formKeyPressed
  {//GEN-HEADEREND:event_formKeyPressed
    // =============== Spacebar is pressed ===================================
    //        Update spacebar flag and change cursor to a hand.
    if (evt.getKeyCode() == 32)
    {
      spacebar = true;
      setCursor(new Cursor(Cursor.HAND_CURSOR));
    }
    // ============== + key is pressed =======================================
    //          Zoom in image.
    else if (evt.getKeyCode() == 107)
    {
      zoom(0.1);
      repaint();
    }
    // ============== - key is pressed =======================================
    //                Zoom out image.
    else if (evt.getKeyCode() == 109)
    {
      zoom(-0.1);
      repaint();
    }
  }//GEN-LAST:event_formKeyPressed

  private void formKeyReleased(java.awt.event.KeyEvent evt)//GEN-FIRST:event_formKeyReleased
  {//GEN-HEADEREND:event_formKeyReleased
    // ======== Spacebar is released =========================================
    //  Update spacebar flag and change cursor to default.
    if (evt.getKeyCode() == 32)
    {
      spacebar = false;
      setCursor(new Cursor(Cursor.DEFAULT_CURSOR));
    }
  }//GEN-LAST:event_formKeyReleased

  private void formMousePressed(java.awt.event.MouseEvent evt)//GEN-FIRST:event_formMousePressed
  {//GEN-HEADEREND:event_formMousePressed
    mousePos = evt.getPoint();
  }//GEN-LAST:event_formMousePressed

  private void formMouseEntered(java.awt.event.MouseEvent evt)//GEN-FIRST:event_formMouseEntered
  {//GEN-HEADEREND:event_formMouseEntered
    requestFocus();
  }//GEN-LAST:event_formMouseEntered

  // ==========================================================================
  // ===                    ATTRIBUTES
  // ==========================================================================
  /**
   * ImageStack to be displayed.
   */
  private ImageStack image;
  /**
   * optional blobsOrSeedsImage to mixed with image.
   */
  private ImageStack blobsOrSeedsImage;

  /**
   * Slice of the ImageStack to display.
   */
  private int slice = 1;
  /**
   * Zoom
   */
  private double zoom = 1;
  /**
   * Point fixing position of topleft corner in the image when zooming.
   */
  private Point topLeftCorner = new Point(0, 0);
  /**
   * Last width of zoomed image. Used to compute zoom.
   */
  private double lastZoomWidth = 0;
  /**
   * Last height of zoomed image. Used to compute zoom.
   */
  private double lastZoomHeight = 0;
  /**
   * Left top corner image position in panel.
   */
  private Point drawPos = new Point(0, 0);
  /**
   * Attribute used to manage zoom. Registers image dimension before last zoom.
   */
  private Dimension lastSize = new Dimension(0, 0);
  /**
   * Image panel roi to draw.
   */
  private Roi roi;
  /**
   * Is spaceBar pressed ?.
   */
  boolean spacebar = false;
  /**
   * Last mouse position in the panel.
   */
  Point mousePos;

  
  
  /**
   * Linked image panels : will be zoomed when it is zoom and moved when it is
   * moved.
   */
  private ArrayList<ImagePanel> linkedPanels = new ArrayList<ImagePanel>();
  

  // Variables declaration - do not modify//GEN-BEGIN:variables
  // End of variables declaration//GEN-END:variables
  // ==========================================================================
  // ===                     PAINT METHOD
  // ==========================================================================
  /**
   * Calls the UI delegate's paint method, if the UI delegate is non-null.
   *
   * Draws ImageStack selected slice and resize it if necessary.
   *
   * We pass the delegate a copy of the Graphics object to protect the rest of
   * the paint code from irrevocable changes (for example, Graphics.translate).
   *
   * If you override this in a subclass you should not make permanent changes to
   * the passed in Graphics. For example, you should not alter the clip
   * Rectangle or modify the transform. If you need to do these operations you
   * may find it easier to create a new Graphics from the passed in Graphics and
   * manipulate it. Further, if you do not invoker super's implementation you
   * must honor the opaque property, that is if this component is opaque, you
   * must completely fill in the background in a non-opaque color. If you do not
   * honor the opaque property you will likely see visual artifacts.
   *
   * The passed in Graphics object might have a transform other than the
   * identify transform installed on it. In this case, you might get unexpected
   * results if you cumulatively apply another transform.
   *
   * @param g
   */
  @Override
  protected void paintComponent(Graphics g)
  {
    // ========= Call inherited method ========================================
    super.paintComponent(g);

    // ======== If image is empty or slice is not valid, stop method ==========
    if (image.getSize() == 0 || slice <= 0 || slice > image.getSize())
    {
      return;
    }

    // =================== Get image processor to draw ========================
    ImageProcessor iproc = image.getProcessor(slice);
    iproc = iproc.duplicate();

    // ============ If blobsOrSeedsImage is not null, mix it ==============================
    if (blobsOrSeedsImage != null)
    {
      ColorProcessor BlobsProc = (ColorProcessor)blobsOrSeedsImage.getProcessor(slice).convertToRGB();

      iproc = Utils.MixColorProcessors(BlobsProc, (ColorProcessor)iproc.convertToRGB());
    }

    // ================= Draw roi if not null =================================
    if (roi != null)
    {
      iproc.setColor(Color.white);
      iproc.setLineWidth(2);
      iproc.draw(roi);
    }

    // ========== Resize slice ================================================
    int zoomWidth = (int) (image.getWidth() * zoom);
    int zoomHeight = (int) (image.getHeight() * zoom);
    iproc = iproc.resize(zoomWidth, zoomHeight);

    // ============ Crop slice ================================================
    iproc.setRoi(topLeftCorner.x, topLeftCorner.y, getWidth(), getHeight());
    iproc = iproc.crop();

    // =========================== Upadte drawpos point =======================
    int xdraw = (getWidth() - iproc.getWidth()) / 2;
    int ydraw = (getHeight() - iproc.getHeight()) / 2;
    drawPos = new Point(xdraw, ydraw);

    // =========================== Draw image in panel ========================
    g.drawImage(iproc.getBufferedImage(), xdraw, ydraw, null);

  }



  // ==========================================================================
  // ===                       SETTERS
  // ==========================================================================
  

  // --------------------- Set image -----------------------------------------
  /**
   * Changes 'image' of the panel.
   *
   * @param _img new image.
   * @param _slice new slice number.
   */
  public void setImageWithResize(ImageStack _img, int _slice)
  {
    if (_img != null)
    {
      // =========== Resize new Image so to panel size ==========================
      //  so it is not too big.

      // ---------- initiate new resied image -----------------------------------
      ImageStack res = new ImageStack(getWidth(), getHeight());

      // -------- For each slice, resize it and add it to the resized image -----
      int size = _img.getSize();
      for (int i = 1; i < size + 1; i++)
      {
        ImageProcessor ip = _img.getProcessor(i);
        ip = ip.resize(getWidth(), getHeight());
        res.addSlice(ip);
      }

      // ======== Set resied image as new 'image' parameter =====================
      image = res;
    }
    else
    {
      image = new ImageStack();
    }

    // ======== Set _slice as new 'slice' parameter ===========================
    slice = _slice;

    // ======== Update lastZoom width and height ==============================
    zoom = 1;
    lastZoomHeight = image.getHeight();
    lastZoomWidth = image.getWidth();

    // ======== Repaint panel =================================================
    repaint();
  }

  /**
   * Changes 'image' of the panel.
   *
   * @param _img new image.
   * @param _slice new slice number.
   */
  public void setImage(ImageStack _img, int _slice)
  {
    if (_img != null)
    {

      image = _img;
    }
    else
    {
      image = new ImageStack();
    }

    // ======== Set _slice as new 'slice' parameter ===========================
    slice = _slice;

    // ======== Update lastZoom width and height ==============================
    lastZoomHeight = image.getHeight();
    lastZoomWidth = image.getWidth();
    zoom = 1;

    // ======== Resize panel ==================================================
    setPreferredSize(new Dimension(image.getWidth(), image.getHeight()));
    setSize(image.getWidth(), image.getHeight());

    // ======== Repaint panel =================================================
    repaint();
  }

  /**
   * Replaces the imageProcessor of slice 'slice' in the stack by a new
   * imageProcessor.
   *
   * @param IP new imageProcessor
   * @param slice slice number
   */
  public void setImageProcessor(ImageProcessor IP, int slice)
  {
    // ============== Resize imageProcessor if necessary ======================
    if (IP.getWidth() != image.getWidth() || IP.getHeight() != image.getHeight())
    {
      IP = IP.resize(image.getWidth(), image.getHeight());
    }

    // ============ replace ImageProcessor in slice 'slice' ===================
    image.setPixels(IP.getPixels(), slice);

    // =========== repaint ====================================================
    repaint();
  }

  // --------------------- Set blobsOrSeedsImage -----------------------------------------
  public void setBlobsOrSeedsImage(ImageStack _blobs)
  {
    int width = image.getWidth();
    int height = image.getHeight();
    int size = image.getSize();

    if (_blobs == null)
    {
      blobsOrSeedsImage = null;
    }
    else if (_blobs.getWidth() != width || _blobs.getHeight() != height)
    {
      ImageStack res = new ImageStack(width, height);

      // -------- For each slice, resize it and add it to the resized image -----
      for (int i = 1; i < size + 1; i++)
      {
        ImageProcessor ip = _blobs.getProcessor(i);
        ip = ip.resize(getWidth(), getHeight());
        res.addSlice(ip);
      }

      blobsOrSeedsImage = res;
    }
    else
    {
      blobsOrSeedsImage = _blobs;
    }

    repaint();
  }

  public void setBlobsOrSeedsImage(int slice, ColorProcessor _blobs)
  {
    // ============== Resize imageProcessor if necessary ======================
    if (_blobs.getWidth() != image.getWidth() || _blobs.getHeight() != image.
        getHeight())
    {
      _blobs = (ColorProcessor) _blobs.resize(image.getWidth(), image.
          getHeight());
    }

    // ============ replace ImageProcessor in slice 'slice' ===================
    blobsOrSeedsImage.setPixels(_blobs.getPixels(), slice);

    // =========== repaint ====================================================
    repaint();
  }

  // --------------------- Set others -----------------------------------------
  /**
   * Changes slice number to show.
   *
   * @param _slice
   */
  public void setSlice(int _slice)
  {
    // -------- Change new slice number ---------------------------------
    slice = _slice;

    // ----------repaint panel -----------------------------------------
    repaint();
  }

  /**
   * Change zoom in image : if 'val' is negative, it zooms out, else it zooms
   * in.
   *
   * @param val
   */
  public void zoom(double val)
  {
    //DEBUG
    System.out.println("===== ZOOM event =====");
    System.out.print("  Zoom changed from " + zoom);

    // ==================== Zoom is minimum 0.1 ===============================
    zoom = Math.max(0.1, zoom + val);

    // DEBUG
    System.out.println(" to " + zoom);

    // ================ Init of new zoom width and height =====================
    double currZoomWidth = image.getWidth() * zoom;
    double currZoomHeight = image.getHeight() * zoom;

    // ====== Compute new left top corner of zoomed image in original image ===
    // If zoomed image is smaller than panel, left top corner of zoomed image 
    // is the left top corner of original image.
    // Else, only a part of the image can be displayed in panel and we put its 
    // left top corner so that centered displayed point is not changed.
    // ------- Compute width and height differences with precedent zoom -------
    double diffZoomWidth = (currZoomWidth - lastZoomWidth) / 2;
    double diffZoomHeight = (currZoomHeight - lastZoomHeight) / 2;

    // ------ If zoom width is inferior to panel width ------------------------
    //  whole image width can be displayed. So left top corner x coordinate = 0.
    if (currZoomWidth <= getWidth())
    {
      topLeftCorner.x = 0;
    }
    // ----  If zoom width is superior to panel width -------------------------
    //  whole image width can't be displayed. 
    //  So left top corner x coordinate is added width difference with precedent zoom
    //  so that centered point stay the same.
    //  left top corner x coordinate is minimum 0 and maximum currZoomWidth - panel width
    else
    {
      int maxX = getCornerMaxX();
      topLeftCorner.x += diffZoomWidth;
      topLeftCorner.x = Math.min(topLeftCorner.x, maxX);
      topLeftCorner.x = Math.max(topLeftCorner.x, 0);
    }

    // ------ If zoom height is inferior to panel height ------------------------
    //  whole image height can be displayed. So left top corner y coordinate = 0.
    if (currZoomHeight <= getHeight())
    {
      topLeftCorner.y = 0;
    }
    // ----  If zoom height is superior to panel height -------------------------
    //  whole image height can't be displayed. 
    //  So left top corner y coordinate is added height difference with precedent zoom
    //  so that centered point stay the same.
    //  left top corner y coordinate is minimum 0 and maximum currZoomHeight - panel height
    else
    {
      int maxY = getCornerMaxY();
      topLeftCorner.y += diffZoomHeight;
      topLeftCorner.y = Math.min(topLeftCorner.y, maxY);
      topLeftCorner.y = Math.max(topLeftCorner.y, 0);
    }

    // ============= Update last zoom width and height ========================
    lastZoomWidth = currZoomWidth;
    lastZoomHeight = currZoomHeight;

    repaint();

    //DEBUG
    System.out.println();
  }

  /**
   * Moves displayed part of image horizontally.
   *
   * @param val
   */
  public void horizontalMove(int val)
  {
    // ========= Compute maximum value of topLeftCorner x coordinates =========
    //   So that image will never be out of the frame. 
    int maxX = getCornerMaxX();

    // ========= Add 'val' to topLeftCorner x coordinate ======================
    topLeftCorner.x += val;

    // == make sure x coordinate is not bigger then maxX nor smaller than 0 ===
    topLeftCorner.x = Math.min(topLeftCorner.x, maxX);
    topLeftCorner.x = Math.max(topLeftCorner.x, 0);

    repaint();
  }

  /**
   * Moves displayed part of image vertically.
   *
   * @param val
   */
  public void verticalMove(int val)
  {
    // ========= Compute maximum value of topLeftCorner y coordinates =========
    //   So that image will never be out of the frame. 
    int maxY = getCornerMaxY();

    // ========= Add 'val' to topLeftCorner y coordinate ======================
    topLeftCorner.y += val;

    // == make sure y coordinate is not bigger then maxY nor smaller than 0 ===
    topLeftCorner.y = Math.min(topLeftCorner.y, maxY);
    topLeftCorner.y = Math.max(topLeftCorner.y, 0);

    repaint();
  }

  /**
   * Set new roi to be draw with image.
   *
   * @param _roi
   */
  public void setRoi(Roi _roi)
  {
    roi = _roi;

    repaint();
  }

  public void setTopLeftCorner(Point _topleftcorner)
  {
    topLeftCorner = _topleftcorner;

    // ========= Compute maximum value of topLeftCorner y coordinates =========
    //   So that image will never be out of the frame. 
    int maxY = getCornerMaxY();

    // == make sure y coordinate is not bigger then maxY nor smaller than 0 ===
    topLeftCorner.y = Math.min(topLeftCorner.y, maxY);
    topLeftCorner.y = Math.max(topLeftCorner.y, 0);

    // ========= Compute maximum value of topLeftCorner x coordinates =========
    //   So that image will never be out of the frame. 
    int maxX = getCornerMaxX();

    // == make sure x coordinate is not bigger then maxX nor smaller than 0 ===
    topLeftCorner.x = Math.min(topLeftCorner.x, maxX);
    topLeftCorner.x = Math.max(topLeftCorner.x, 0);

    repaint();
  }

  // ==========================================================================
  // ===                       GETTERS
  // ==========================================================================
  /**
   * Get slice shown number.
   *
   * @return
   */
  public int getSlice()
  {
    return slice;
  }

  /**
   * Returns imageStack of the panel.
   *
   * @return
   */
  public ImageStack getImage()
  {
    return image;
  }

  public ImageStack getBlobsOrSeedsStack()
  {
    return blobsOrSeedsImage;
  }

  /**
   * Returns width of the imageStack.
   *
   * @return
   */
  public int getIWidth()
  {
    return image.getWidth();
  }

  /**
   * Returns height of the imageStack.
   *
   * @return
   */
  public int getIHeight()
  {
    return image.getHeight();
  }

  /**
   * Returns zoom.
   *
   * @return
   */
  public double getZoom()
  {
    return zoom;
  }

  /**
   * Returns position of the topleft corner of the shown image in the original
   * imageStack.
   *
   * @return
   */
  public Point getTopLeftCorner()
  {
    return topLeftCorner;
  }

  /**
   * Returns drawing position in the frame.
   *
   * @return
   */
  public Point getDrawPos()
  {
    return drawPos;
  }

  /**
   * Computes zoom so that image exactly fill the frame.
   *
   * @return
   */
  private double getZoomToFill()
  {

    // ==== Computes zoom so that image width will exactly fill frame width ===
    double zoomWidth = (double) getWidth() / (double) image.getWidth();

    // == Computes zoom so that image height will exactly fill frame height ===
    double zoomHeight = (double) getHeight() / (double) image.getHeight();

    // ======== returns minimum of zoomWidth and zoomHeight ===================
    //   if it is bigger than 0.1, else returns 0.1
    double newZoom = Math.min(zoomWidth, zoomHeight);
    newZoom = Math.max(0.1, newZoom);
    return newZoom;
  }

  private int getCornerMaxX()
  {
    return (int) (image.getWidth() * zoom - getWidth() - 1);
  }

  private int getCornerMaxY()
  {
    return (int) (image.getHeight() * zoom - getHeight() - 1);
  }

  // ==========================================================================
  // ===                      OTHERS METHODS
  // ==========================================================================
  /**
   * Set 'image' as a black ImageStack of 'size' number of slices.
   *
   * @param size
   */
  public void fillBlack(int size)
  {
    // =========== Initiate variables =========================================
    int width = getWidth();
    int height = getHeight();
    ImageStack img = new ImageStack(width, height, size);

    // ============ Fill imageStack with black ================================
    int nbPix = width * height;
    short[] pixs = new short[nbPix];
    for (int i = 0; i < nbPix; i++)
    {
      pixs[i] = 0;
    }

    for (int i = 1; i <= size; i++)
    {
    	img.addSlice("", new ShortProcessor(width, height, pixs, getColorModel()),i);
    	
    }

    // ============ change image and repaint ==================================
    image = img;
    repaint();
  }

  /**
   * Resizes frame so that it will fit exactly image.
   *
   */
  private void resizeToZoom()
  {
    // ========== Computes new dimensions =====================================
    int newWidth = (int) (zoom * image.getWidth());
    int newHeight = (int) (zoom * image.getHeight());
    Dimension newSize = new Dimension(newWidth, newHeight);

    // ========== Update size and preferred size ==============================
    setPreferredSize(newSize);
    setSize(newSize);

    // ========== repaint =====================================================
    repaint();
  }

  /**
   * Returns index of the clicked pixel at position (x,y) in imageblobs.
   *
   * @param x
   * @param y
   * @return
   */
  public int getPixIndexFromClick(int x, int y)
  {
    return Utils.pointToIndex(getPixFromClick(x, y), image.getWidth(), image.
        getHeight());
  }

  /**
   * Returns index of the clicked pixel at position (x,y) in imageblobs.
   *
   * @param pt
   * @return
   */
  public int getPixIndexFromClick(Point pt)
  {
    return Utils.pointToIndex(getPixFromClick(pt.x, pt.y), image.getWidth(),
                              image.getHeight());
  }

  /**
   * Returns the clicked pixel at position (x,y) in imageblobs.
   *
   * @param x
   * @param y
   * @return
   */
  public Point getPixFromClick(int x, int y)
  {
    // ========== record mouse position in zoomed image referential ===========
    int newx = (int) ((x + topLeftCorner.x - drawPos.x) / zoom);
    int newy = (int) ((y + topLeftCorner.y - drawPos.y) / zoom);

    return new Point(newx, newy);
  }

  /**
   * Returns the clicked pixel at position (x,y) in imageblobs.
   *
   * @param pt
   * @return
   */
  public Point getPixFromClick(Point pt)
  {
    return getPixFromClick(pt.x, pt.y);
  }
  
  /**
   * Adds ImagePanel to linkedPanels. It will zoom when this image zoom, 
   * move when this image move...
   * 
   * @param linkedPanel the linkedPanelPanel to add
   */
   public void addLinkedImage(ImagePanel linkedPanel)
  {
    // ========== Update linked images ========================================
    addKeyListener(linkedPanel.getKeyListeners()[0]);
    addMouseListener(linkedPanel.getMouseListeners()[0]);
    addMouseMotionListener(linkedPanel.getMouseMotionListeners()[0]);
    
    // ============= Add linked images ========================================
    this.linkedPanels.add(linkedPanel);
  }
   
   public void mutualLink( ImagePanel linkedPanel)
   {
     linkedPanel.addLinkedImage(this);
     this.addLinkedImage(linkedPanel);
   }
  
}
